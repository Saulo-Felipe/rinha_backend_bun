{
  "version": 3,
  "sources": ["../../src/index.ts"],
  "sourcesContent": [
    "export interface FindResult<T> {\n    store: T\n    params: Record<string, any>\n}\n\nexport interface ParamNode<T> {\n    paramName: string\n    store: T | null\n    inert: Node<T> | null\n}\n\nexport interface Node<T> {\n    part: string\n    store: T | null\n    inert: Map<number, Node<T>> | null\n    params: ParamNode<T> | null\n    wildcardStore: T | null\n}\n\nconst createNode = <T>(part: string, inert?: Node<T>[]): Node<T> => ({\n    part,\n    store: null,\n    inert:\n        inert !== undefined\n            ? new Map(inert.map((child) => [child.part.charCodeAt(0), child]))\n            : null,\n    params: null,\n    wildcardStore: null\n})\n\nconst cloneNode = <T>(node: Node<T>, part: string) => ({\n    ...node,\n    part\n})\n\nconst createParamNode = <T>(paramName: string): ParamNode<T> => ({\n    paramName,\n    store: null,\n    inert: null\n})\n\nexport class Memoirist<T> {\n    root: Record<string, Node<T>> = {}\n    history: [string, string, T][] = []\n\n    private static regex = {\n        static: /:.+?(?=\\/|$)/,\n        params: /:.+?(?=\\/|$)/g\n    }\n\n    add(method: string, path: string, store: T): FindResult<T>['store'] {\n        if (typeof path !== 'string')\n            throw new TypeError('Route path must be a string')\n\n        if (path === '') path = '/'\n        else if (path[0] !== '/') path = `/${path}`\n\n        this.history.push([method, path, store])\n\n        const isWildcard = path[path.length - 1] === '*'\n        if (isWildcard) {\n            // Slice off trailing '*'\n            path = path.slice(0, -1)\n        }\n\n        const inertParts = path.split(Memoirist.regex.static)\n        const paramParts = path.match(Memoirist.regex.params) || []\n\n        if (inertParts[inertParts.length - 1] === '') inertParts.pop()\n\n        let node: Node<T>\n\n        if (!this.root[method]) node = this.root[method] = createNode<T>('/')\n        else node = this.root[method]\n\n        let paramPartsIndex = 0\n\n        for (let i = 0; i < inertParts.length; ++i) {\n            let part = inertParts[i]\n\n            if (i > 0) {\n                // Set param on the node\n                const param = paramParts[paramPartsIndex++].slice(1)\n\n                if (node.params === null) node.params = createParamNode(param)\n                else if (node.params.paramName !== param)\n                    throw new Error(\n                        `Cannot create route \"${path}\" with parameter \"${param}\" ` +\n                            'because a route already exists with a different parameter name ' +\n                            `(\"${node.params.paramName}\") in the same location`\n                    )\n\n                const params = node.params\n\n                if (params.inert === null) {\n                    node = params.inert = createNode(part)\n                    continue\n                }\n\n                node = params.inert\n            }\n\n            for (let j = 0; ; ) {\n                if (j === part.length) {\n                    if (j < node.part.length) {\n                        // Move the current node down\n                        const childNode = cloneNode(node, node.part.slice(j))\n                        Object.assign(node, createNode(part, [childNode]))\n                    }\n                    break\n                }\n\n                if (j === node.part.length) {\n                    // Add static child\n                    if (node.inert === null) node.inert = new Map()\n                    else if (node.inert.has(part.charCodeAt(j))) {\n                        // Re-run loop with existing static node\n                        node = node.inert.get(part.charCodeAt(j))!\n                        part = part.slice(j)\n                        j = 0\n                        continue\n                    }\n\n                    // Create new node\n                    const childNode = createNode<T>(part.slice(j))\n                    node.inert.set(part.charCodeAt(j), childNode)\n                    node = childNode\n\n                    break\n                }\n\n                if (part[j] !== node.part[j]) {\n                    // Split the node\n                    const existingChild = cloneNode(node, node.part.slice(j))\n                    const newChild = createNode<T>(part.slice(j))\n\n                    Object.assign(\n                        node,\n                        createNode(node.part.slice(0, j), [\n                            existingChild,\n                            newChild\n                        ])\n                    )\n\n                    node = newChild\n\n                    break\n                }\n\n                ++j\n            }\n        }\n\n        if (paramPartsIndex < paramParts.length) {\n            // The final part is a parameter\n            const param = paramParts[paramPartsIndex]\n            const paramName = param.slice(1)\n\n            if (node.params === null) node.params = createParamNode(paramName)\n            else if (node.params.paramName !== paramName)\n                throw new Error(\n                    `Cannot create route \"${path}\" with parameter \"${paramName}\" ` +\n                        'because a route already exists with a different parameter name ' +\n                        `(\"${node.params.paramName}\") in the same location`\n                )\n\n            if (node.params.store === null) node.params.store = store\n\n            return node.params.store!\n        }\n\n        if (isWildcard) {\n            // The final part is a wildcard\n            if (node.wildcardStore === null) node.wildcardStore = store\n\n            return node.wildcardStore!\n        }\n\n        // The final part is static\n        if (node.store === null) node.store = store\n\n        return node.store!\n    }\n\n    find(method: string, url: string): FindResult<T> | null {\n        const root = this.root[method]\n        if (!root) return null\n\n        return matchRoute(url, url.length, root, 0)\n    }\n}\n\nconst matchRoute = <T>(\n    url: string,\n    urlLength: number,\n    node: Node<T>,\n    startIndex: number\n): FindResult<T> | null => {\n    const part = node?.part\n    const endIndex = startIndex + part.length\n\n    // Only check the pathPart if its length is > 1 since the parent has\n    // already checked that the url matches the first character\n    if (part.length > 1) {\n        if (endIndex > urlLength) return null\n\n        if (part.length < 15) {\n            // Using a loop is faster for short strings\n            for (let i = 1, j = startIndex + 1; i < part.length; ++i, ++j)\n                if (part.charCodeAt(i) !== url.charCodeAt(j)) return null\n        } else if (url.substring(startIndex, endIndex) !== part) return null\n    }\n\n    if (endIndex === urlLength) {\n        // Reached the end of the URL\n        if (node.store !== null)\n            return {\n                store: node.store,\n                params: {}\n            }\n\n        if (node.wildcardStore !== null)\n            return {\n                store: node.wildcardStore,\n                params: { '*': '' }\n            }\n\n        return null\n    }\n\n    if (node.inert !== null) {\n        const inert = node.inert.get(url.charCodeAt(endIndex))\n\n        if (inert !== undefined) {\n            const route = matchRoute(url, urlLength, inert, endIndex)\n\n            if (route !== null) return route\n        }\n    }\n\n    if (node.params !== null) {\n        const param = node.params\n        const slashIndex = url.indexOf('/', endIndex)\n\n        if (slashIndex !== endIndex) {\n            // Params cannot be empty\n            if (slashIndex === -1 || slashIndex >= urlLength) {\n                if (param.store !== null) {\n                    // This is much faster than using a computed property\n                    const params: Record<string, string> = {}\n\n                    params[param.paramName] = url.substring(endIndex, urlLength)\n\n                    return {\n                        store: param.store,\n                        params\n                    }\n                }\n            } else if (param.inert !== null) {\n                const route = matchRoute(\n                    url,\n                    urlLength,\n                    param.inert,\n                    slashIndex\n                )\n\n                if (route !== null) {\n                    route.params[param.paramName] = url.substring(\n                        endIndex,\n                        slashIndex\n                    )\n\n                    return route\n                }\n            }\n        }\n    }\n\n    if (node.wildcardStore !== null)\n        return {\n            store: node.wildcardStore,\n            params: {\n                '*': url.substring(endIndex, urlLength)\n            }\n        }\n\n    return null\n}\n\nexport default Memoirist\n"
  ],
  "mappings": "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",
  "debugId": "9F5E991AE891E51664756e2164756e21",
  "names": []
}